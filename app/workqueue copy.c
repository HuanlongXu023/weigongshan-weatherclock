#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "workqueue.h"

/* ============================================================================
 * 工作消息结构体
 * 封装了要在工作队列中执行的任务信息
 * ============================================================================ */
typedef struct
{
    work_t work;    // 工作函数指针（要执行的函数）
    void *param;    // 工作函数的参数
} work_message_t;

/* ============================================================================
 * FreeRTOS消息队列句柄
 * 用于在不同任务间传递工作请求
 * ============================================================================ */
static QueueHandle_t work_msg_queue;

/* ============================================================================
 * 函数：work_func
 * 功能：工作队列任务主函数
 * 参数：param - 任务参数（未使用）
 * 说明：
 *   - 这是一个FreeRTOS任务，独立运行在自己的栈空间
 *   - 从消息队列中接收工作请求并执行
 *   - 串行化所有工作任务的执行，避免并发冲突
 *   - 适用于不适合在定时器中断中执行的耗时操作
 * 
 * 设计目的：
 *   FreeRTOS定时器回调函数运行在定时器服务任务中，有以下限制：
 *   1. 不能执行耗时操作（会阻塞其他定时器）
 *   2. 不能调用会阻塞的API（如vTaskDelay）
 *   3. 栈空间有限
 *   
 *   工作队列任务解决了这些问题：
 *   1. 拥有独立的栈空间（1024字）
 *   2. 可以执行耗时操作（如网络请求、I2C通信）
 *   3. 可以调用任何FreeRTOS API
 * ============================================================================ */
static void work_func(void *param)
{
    work_message_t msg;  // 工作消息缓冲区
    
    /* ------------------------------------------------------------------------
     * 无限循环：处理工作队列中的任务
     * ------------------------------------------------------------------------ */
    while (1)
    {
        /* --------------------------------------------------------------------
         * 从队列接收工作消息（阻塞等待）
         * portMAX_DELAY: 如果队列为空，永久阻塞直到有消息到达
         * 这样可以让任务在没有工作时进入阻塞状态，节省CPU资源
         * -------------------------------------------------------------------- */
        xQueueReceive(work_msg_queue, &msg, portMAX_DELAY);
        
        /* --------------------------------------------------------------------
         * 执行工作函数
         * msg.work: 函数指针，指向要执行的函数
         * msg.param: 传递给工作函数的参数
         * 
         * 示例：
         *   如果 msg.work = time_sync, msg.param = NULL
         *   则执行 time_sync(NULL)
         * -------------------------------------------------------------------- */
        msg.work(msg.param);
    }
}

/* ============================================================================
 * 函数：workqueue_init
 * 功能：初始化工作队列系统
 * 说明：
 *   1. 创建消息队列
 *   2. 创建工作队列任务
 *   必须在使用workqueue_run()之前调用
 * ============================================================================ */
void workqueue_init(void)
{
    /* ------------------------------------------------------------------------
     * 创建消息队列
     * 参数1：队列长度 - 最多可以缓存16个待执行的工作
     * 参数2：消息大小 - 每条消息的字节数（work_message_t结构体大小）
     * 
     * 队列长度设计考虑：
     *   - 太小：可能导致生产者（如定时器）阻塞等待队列有空间
     *   - 太大：占用过多RAM
     *   - 16个：足够缓冲多个定时器同时触发的情况
     * ------------------------------------------------------------------------ */
    work_msg_queue = xQueueCreate(16, sizeof(work_message_t));
    configASSERT(work_msg_queue);  // 断言：队列创建必须成功，否则系统无法正常工作
    
    /* ------------------------------------------------------------------------
     * 创建工作队列任务
     * 参数1：任务函数指针
     * 参数2：任务名称 - "workqueue"（用于调试，可在FreeRTOS调试器中查看）
     * 参数3：栈大小 - 1024字（4KB，因为StackType_t是uint32_t）
     *        足够执行大多数工作函数，包括：
     *        - 网络HTTP请求（outdoor_update）
     *        - I2C传感器读取（inner_update）
     *        - SNTP时间同步（time_sync）
     * 参数4：任务参数 - NULL（work_func不需要参数）
     * 参数5：任务优先级 - 5（中等优先级）
     *        比UI任务(8)低：保证UI响应优先
     *        比空闲任务(0)高：保证工作能及时执行
     * 参数6：任务句柄 - NULL（不需要保存句柄）
     * ------------------------------------------------------------------------ */
    xTaskCreate(work_func, "workqueue", 1024, NULL, 5, NULL);
}

/* ============================================================================
 * 函数：workqueue_run
 * 功能：提交一个工作到工作队列
 * 参数：
 *   work  - 要执行的工作函数指针
 *   param - 传递给工作函数的参数
 * 说明：
 *   - 函数立即返回，不等待工作执行完成（异步操作）
 *   - 工作会在工作队列任务中串行执行
 *   - 如果队列已满，会阻塞等待直到有空间
 * 
 * 使用场景示例：
 *   1. 定时器回调中提交耗时工作：
 *      workqueue_run(app_work, time_sync);  // 执行网络时间同步
 *   
 *   2. 系统初始化时立即执行工作：
 *      workqueue_run(app_work, wifi_update);  // 立即检查WiFi状态
 *   
 *   3. 带参数的工作：
 *      workqueue_run(process_data, &sensor_data);  // 处理传感器数据
 * ============================================================================ */
void workqueue_run(work_t work, void *param)
{
    /* ------------------------------------------------------------------------
     * 断言检查：确保工作队列已初始化
     * 如果work_msg_queue为NULL，说明忘记调用workqueue_init()
     * configASSERT会触发断言失败，帮助开发者发现问题
     * ------------------------------------------------------------------------ */
    configASSERT(work_msg_queue);
    
    /* ------------------------------------------------------------------------
     * 创建工作消息
     * 使用C99复合字面量语法，简洁地初始化结构体
     * ------------------------------------------------------------------------ */
    work_message_t msg = { work, param };
    
    /* ------------------------------------------------------------------------
     * 将消息发送到队列
     * portMAX_DELAY: 如果队列已满，永久阻塞直到有空间
     * 
     * 注意：
     *   - 这个函数可能会阻塞（如果队列满了）
     *   - 在中断服务程序中不能使用，应使用xQueueSendFromISR()
     *   - 消息是按值复制的，所以msg是局部变量也没问题
     * ------------------------------------------------------------------------ */
    xQueueSend(work_msg_queue, &msg, portMAX_DELAY);
}
 
