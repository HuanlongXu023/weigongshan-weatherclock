#include <stdint.h>
#include <stdio.h>
#include "FreeRTOS.h"
#include "task.h"
#include "stm32f4xx.h"
#include "tim_delay.h"
#include "console.h"
#include "rtc.h"
#include "aht20.h"

/* ============================================================================
 * 函数：board_lowlevel_init
 * 功能：底层硬件初始化（在main函数最开始调用，先于FreeRTOS启动）
 * 说明：
 *   - 使能所有GPIO端口时钟
 *   - 使能外设时钟
 *   - 配置RTC时钟源
 *   这些初始化必须在系统启动早期完成，为后续驱动初始化做准备
 * ============================================================================ */
void board_lowlevel_init(void)
{
    /* ------------------------------------------------------------------------
     * 第一步：使能所有GPIO端口的时钟
     * STM32的外设默认是关闭时钟的（省电），使用前必须先使能时钟
     * ------------------------------------------------------------------------ */
    
    /* GPIOA时钟使能
     * 用途：USART1（TX/RX）、SPI、ADC等 */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    
    /* GPIOB时钟使能
     * 用途：I2C2（AHT20温湿度传感器）、SPI2等 */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    
    /* GPIOC时钟使能
     * 用途：通用GPIO、LED、按键等 */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    
    /* GPIOD时钟使能
     * 用途：通用GPIO */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    
    /* GPIOE时钟使能
     * 用途：通用GPIO、LCD控制引脚等 */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    
    /* ------------------------------------------------------------------------
     * 第二步：使能APB2总线上的外设时钟
     * APB2是高速外设总线
     * ------------------------------------------------------------------------ */
    
    /* USART1时钟使能
     * 用途：调试串口（printf输出）
     * 连接：PA9(TX)、PA10(RX) */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    
    /* ------------------------------------------------------------------------
     * 第三步：使能APB1总线上的外设时钟
     * APB1是低速外设总线
     * ------------------------------------------------------------------------ */
    
    /* USART2时钟使能
     * 用途：ESP-AT模块通信（WiFi模块）
     * 连接ESP8266/ESP32的TX/RX */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    
    /* I2C2时钟使能
     * 用途：AHT20温湿度传感器通信
     * 连接：PB10(SCL)、PB11(SDA) */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
    
    /* SPI2时钟使能
     * 用途：ST7789 LCD屏幕通信
     * 高速串行通信接口 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    
    /* TIM6定时器时钟使能
     * 用途：系统微秒级延时定时器
     * 提供tim_delay_us()和tim_delay_ms()函数 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
    
    /* PWR电源控制时钟使能
     * 用途：访问RTC后备域需要使能电源控制 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
    
    /* ------------------------------------------------------------------------
     * 第四步：使能DMA控制器时钟
     * DMA用于高速数据传输，减轻CPU负担
     * ------------------------------------------------------------------------ */
    
    /* DMA1时钟使能
     * 用途：低速外设DMA传输（USART、I2C、SPI等） */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
    
    /* DMA2时钟使能
     * 用途：高速外设DMA传输（USART1的TX使用DMA2_Stream7） */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
    
    /* ------------------------------------------------------------------------
     * 第五步：配置RTC（实时时钟）时钟源
     * ------------------------------------------------------------------------ */
    
    /* 使能后备域访问
     * RTC寄存器位于后备域（Backup Domain），需要特殊权限才能访问
     * 后备域由VBAT（备用电池）供电，主电源掉电时仍能保持RTC运行 */
    PWR_BackupAccessCmd(ENABLE);
    
    /* 使能LSE（Low Speed External）外部低速晶振
     * LSE通常是32.768kHz晶振，为RTC提供精确的时钟源
     * 相比内部LSI（32kHz RC振荡器），LSE精度更高、温度漂移更小 */
    RCC_LSEConfig(RCC_LSE_ON);
    
    /* 等待LSE晶振稳定
     * LSE启动需要一定时间（通常几毫秒到几百毫秒）
     * RCC_FLAG_LSERDY标志位置1表示LSE已稳定可用 */
    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);
    
    /* 选择LSE作为RTC时钟源
     * RTC时钟源可选：
     *   - LSE（外部32.768kHz晶振）：精度高，推荐
     *   - LSI（内部32kHz RC）：精度低，但无需外部晶振
     *   - HSE/128（高速外部晶振分频）：不推荐用于RTC */
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
}
 
/* ============================================================================
 * 函数：board_init
 * 功能：板级外设初始化（在FreeRTOS启动前调用）
 * 说明：
 *   - 初始化基础外设驱动
 *   - 打印系统启动信息
 *   - 为应用层提供基础服务
 * ============================================================================ */
void board_init(void)
{
    /* ------------------------------------------------------------------------
     * 初始化定时器延时功能
     * 功能：
     *   - 配置TIM6定时器为1MHz计数频率（1us分辨率）
     *   - 提供tim_delay_us()和tim_delay_ms()函数
     *   - 提供tim_now()获取微秒级时间戳
     * 用途：
     *   - I2C时序延时
     *   - 传感器等待时间
     *   - 性能测试计时
     * ------------------------------------------------------------------------ */
    tim_delay_init();
    
    /* ------------------------------------------------------------------------
     * 初始化控制台（调试串口）
     * 功能：
     *   - 配置USART1为115200波特率
     *   - 配置DMA用于串口发送（提高效率）
     *   - 重定向printf到USART1
     * 用途：
     *   - 系统调试信息输出
     *   - 错误日志记录
     *   - 性能监控
     * ------------------------------------------------------------------------ */
    console_init();
    
    /* ------------------------------------------------------------------------
     * 打印系统编译信息
     * __DATE__：编译日期（如 "Dec 01 2025"）
     * __TIME__：编译时间（如 "14:30:45"）
     * 用途：
     *   - 确认固件版本
     *   - 调试时识别是否烧录了最新固件
     * ------------------------------------------------------------------------ */
    printf("[SYS] Build Date: %s %s\n", __DATE__, __TIME__);
    
    /* ------------------------------------------------------------------------
     * 初始化RTC（实时时钟）
     * 功能：
     *   - 配置RTC为日历模式
     *   - 使能RTC时钟（LSE已在board_lowlevel_init中配置）
     *   - 等待RTC寄存器同步
     * 用途：
     *   - 保存当前日期和时间
     *   - 通过SNTP网络时间同步更新
     *   - 提供时间显示
     * 注意：
     *   - RTC由VBAT备用电池供电，主电源断电后仍能保持时间
     *   - 首次上电或电池耗尽后，时间需要重新设置
     * ------------------------------------------------------------------------ */
    rtc_init();
     
    /* ------------------------------------------------------------------------
     * 初始化AHT20温湿度传感器
     * 功能：
     *   - 配置I2C2接口（PB10/SCL, PB11/SDA）
     *   - 发送AHT20初始化命令
     *   - 校准传感器（如需要）
     *   - 等待传感器就绪
     * 传感器参数：
     *   - I2C地址：0x38
     *   - 测量范围：温度 -40~85°C，湿度 0~100%RH
     *   - 精度：±0.3°C，±2%RH
     *   - 测量时间：约80ms
     * 用途：
     *   - 测量室内温度
     *   - 测量室内湿度
     *   - 环境监测
     * ------------------------------------------------------------------------ */
    aht20_init();
}

/* ============================================================================
 * 函数：fputc
 * 功能：重定向标准输出字符函数（printf底层调用）
 * 参数：
 *   ch - 要输出的字符
 *   f  - 文件指针（未使用）
 * 返回值：输出的字符
 * 说明：
 *   - C标准库的printf最终会调用fputc逐字符输出
 *   - 通过重定义fputc，可以将printf重定向到任意设备
 *   - 这里重定向到USART1串口
 * 
 * 示例：
 *   printf("Hello World\n");
 *   → 依次调用 fputc('H'), fputc('e'), fputc('l'), ... fputc('\n')
 * ============================================================================ */
int fputc(int ch, FILE *f)
{
    /* ------------------------------------------------------------------------
     * 将字符发送到USART1数据寄存器
     * USART_SendData：将字符写入USART1->DR寄存器
     * (uint8_t)ch：将int类型转换为8位字符
     * ------------------------------------------------------------------------ */
    USART_SendData(USART1, (uint8_t)ch);
    
    /* ------------------------------------------------------------------------
     * 等待发送完成
     * USART_FLAG_TXE：发送数据寄存器空标志
     * RESET：标志未置位（寄存器还有数据未发送）
     * 
     * 为什么要等待？
     *   - USART是串行接口，发送需要时间
     *   - 如果不等待，下一个字符可能会覆盖当前字符
     *   - 115200波特率下，发送一个字符约需87us
     * ------------------------------------------------------------------------ */
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    
    /* ------------------------------------------------------------------------
     * 返回发送的字符
     * fputc的标准要求：成功返回字符本身，失败返回EOF
     * ------------------------------------------------------------------------ */
    return ch;
}

/* ============================================================================
 * 函数：vAssertCalled
 * 功能：FreeRTOS断言失败处理函数
 * 参数：
 *   file - 断言失败的源文件名
 *   line - 断言失败的行号
 * 说明：
 *   - 当configASSERT()宏中的条件为假时调用
 *   - 表示程序出现严重错误，需要立即停止运行
 *   - 用于调试期间发现和定位问题
 * 
 * 常见触发场景：
 *   - 队列/信号量创建失败（内存不足）
 *   - 任务栈溢出
 *   - 空指针访问
 *   - 参数验证失败
 * ============================================================================ */
void vAssertCalled(const char *file, int line)
{
    /* ------------------------------------------------------------------------
     * 禁用所有中断
     * 原因：
     *   - 断言失败表示系统状态不可预测
     *   - 继续响应中断可能导致更严重的错误
     *   - 冻结系统状态便于调试
     * ------------------------------------------------------------------------ */
    portDISABLE_INTERRUPTS();
    
    /* ------------------------------------------------------------------------
     * 打印断言失败信息
     * 格式：Assert Called: filename(line_number)
     * 示例：Assert Called: app.c(123)
     * 
     * 通过串口输出，开发者可以：
     *   1. 快速定位问题文件和行号
     *   2. 分析断言失败原因
     *   3. 修复代码或增加资源
     * ------------------------------------------------------------------------ */
    printf("Assert Called: %s(%d)\n", file, line);
    
    /* ------------------------------------------------------------------------
     * 死循环：挂起系统
     * 注意：由于中断已禁用，系统完全停止，需要硬件复位才能恢复
     * ------------------------------------------------------------------------ */
    // 隐式死循环：函数不返回
}


/* ============================================================================
 * 函数：vApplicationStackOverflowHook
 * 功能：任务栈溢出检测钩子函数
 * 参数：
 *   xTask       - 栈溢出的任务句柄
 *   pcTaskName  - 栈溢出的任务名称
 * 说明：
 *   - FreeRTOS在任务切换时检测栈溢出（需要configCHECK_FOR_STACK_OVERFLOW=1）
 *   - 检测到栈溢出时调用此函数
 *   - 栈溢出是严重错误，可能导致数据损坏、系统崩溃
 * 
 * 栈溢出常见原因：
 *   1. 任务栈分配太小
 *   2. 任务中使用了大数组/结构体
 *   3. 递归调用层数过深
 *   4. 中断嵌套过多（中断也使用任务栈）
 * 
 * 解决方法：
 *   1. 增加任务栈大小（xTaskCreate的第3个参数）
 *   2. 将大数组改为动态分配（pvPortMalloc）
 *   3. 优化算法减少栈使用
 * ============================================================================ */
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    /* ------------------------------------------------------------------------
     * 打印栈溢出任务的名称
     * 示例：Stack Overflowed: workqueue
     * 
     * 帮助开发者快速定位是哪个任务的栈不够用
     * ------------------------------------------------------------------------ */
    printf("Stack Overflowed: %s\n", pcTaskName);
    
    /* ------------------------------------------------------------------------
     * 触发断言失败
     * configASSERT(0)：条件永远为假，强制触发断言
     * 
     * 效果：
     *   1. 调用vAssertCalled()打印错误信息
     *   2. 禁用中断
     *   3. 系统挂起
     * ------------------------------------------------------------------------ */
    configASSERT(0);
}

/* ============================================================================
 * 函数：vApplicationMallocFailedHook
 * 功能：内存分配失败钩子函数
 * 说明：
 *   - 当pvPortMalloc()分配内存失败时调用
 *   - 内存不足是严重问题，继续运行可能导致系统崩溃
 * 
 * 内存分配失败常见原因：
 *   1. 堆大小配置太小（configTOTAL_HEAP_SIZE）
 *   2. 内存碎片化（频繁分配/释放导致）
 *   3. 内存泄漏（分配后忘记释放）
 *   4. 某个分配请求过大
 * 
 * 解决方法：
 *   1. 增加堆大小（修改FreeRTOSConfig.h中的configTOTAL_HEAP_SIZE）
 *   2. 使用内存池代替频繁的malloc/free
 *   3. 检查是否有内存泄漏
 *   4. 在编译时静态分配而非运行时动态分配
 * 
 * 当前配置：
 *   configTOTAL_HEAP_SIZE = 92 * 1024 = 94208字节 ≈ 92KB
 * ============================================================================ */
void vApplicationMallocFailedHook(void)
{
    /* ------------------------------------------------------------------------
     * 打印内存分配失败信息
     * ------------------------------------------------------------------------ */
    printf("Malloc Failed\n");
    
    /* ------------------------------------------------------------------------
     * 触发断言失败，挂起系统
     * 理由：内存不足时继续运行非常危险，应立即停止
     * ------------------------------------------------------------------------ */
    configASSERT(0);
}

