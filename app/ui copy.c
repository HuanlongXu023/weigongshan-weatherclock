#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "st7789.h"
#include "ui.h"
#include "font.h"
#include "image.h"

/* ============================================================================
 * UI操作类型枚举
 * 定义UI系统支持的三种基本绘图操作
 * ============================================================================ */
typedef enum
{
    UI_ACTION_FILL_COLOR,      // 填充颜色（矩形区域）
    UI_ACTION_WRITE_STRING,    // 绘制字符串
    UI_ACTION_DRAW_IMAGE,      // 绘制图像
} ui_action_t;

/* ============================================================================
 * UI消息结构体
 * 使用联合体(union)节省内存，因为三种操作的参数不会同时使用
 * ============================================================================ */
typedef struct
{
    ui_action_t action;  // 操作类型（决定使用union中的哪个结构）
    
    union  // 联合体：同一时间只使用其中一个成员
    {
        /* --------------------------------------------------------------------
         * 填充颜色操作的参数
         * -------------------------------------------------------------------- */
        struct
        {
            uint16_t x;         // 矩形左上角X坐标
            uint16_t y;         // 矩形左上角Y坐标
            uint16_t width;     // 矩形宽度
            uint16_t height;    // 矩形高度
            uint16_t color;     // 填充颜色（RGB565格式）
        } fill_color;
        
        /* --------------------------------------------------------------------
         * 绘制字符串操作的参数
         * -------------------------------------------------------------------- */
        struct
        {
            uint16_t x;              // 字符串起始X坐标
            uint16_t y;              // 字符串起始Y坐标
            const char *str;         // 字符串指针（动态分配的内存）
            uint16_t color;          // 前景色（文字颜色）
            uint16_t bg_color;       // 背景色
            const font_t *font;      // 字体指针
        } write_string;
        
        /* --------------------------------------------------------------------
         * 绘制图像操作的参数
         * -------------------------------------------------------------------- */
        struct
        {
            uint16_t x;              // 图像左上角X坐标
            uint16_t y;              // 图像左上角Y坐标
            const image_t *image;    // 图像数据指针
        } draw_image;
    };
} ui_message_t;

/* ============================================================================
 * FreeRTOS消息队列句柄
 * 用于在不同任务间传递UI绘图请求
 * ============================================================================ */
static QueueHandle_t ui_queue;

/* ============================================================================
 * 函数：ui_func
 * 功能：UI任务主函数，从队列接收消息并执行相应的绘图操作
 * 参数：param - 任务参数（未使用）
 * 说明：
 *   - 这是一个FreeRTOS任务，独立运行在自己的栈空间
 *   - 通过消息队列接收来自其他任务的绘图请求
 *   - 串行化所有LCD操作，避免多任务并发访问LCD导致冲突
 * ============================================================================ */
static void ui_func(void *param)
{
    ui_message_t msg;  // 消息缓冲区
    
    /* ------------------------------------------------------------------------
     * 初始化ST7789 LCD驱动
     * 必须在UI任务中初始化，确保所有LCD操作都在同一任务中执行
     * ------------------------------------------------------------------------ */
    st7789_init();
    
    /* ------------------------------------------------------------------------
     * 无限循环：处理UI消息队列
     * ------------------------------------------------------------------------ */
    while (1)
    {
        /* --------------------------------------------------------------------
         * 从队列接收UI消息（阻塞等待）
         * portMAX_DELAY: 如果队列为空，永久阻塞直到有消息到达
         * -------------------------------------------------------------------- */
        xQueueReceive(ui_queue, &msg, portMAX_DELAY);
        
        /* --------------------------------------------------------------------
         * 根据消息类型执行相应的绘图操作
         * -------------------------------------------------------------------- */
        switch (msg.action)
        {
        /* ====================================================================
         * 填充颜色操作
         * ==================================================================== */
        case UI_ACTION_FILL_COLOR:
            st7789_fill_color(msg.fill_color.x, msg.fill_color.y,
                              msg.fill_color.width, msg.fill_color.height,
                              msg.fill_color.color);
            break;
            
        /* ====================================================================
         * 绘制字符串操作
         * ==================================================================== */
        case UI_ACTION_WRITE_STRING:
            st7789_write_string(msg.write_string.x, msg.write_string.y,
                                msg.write_string.str,
                                msg.write_string.color, msg.write_string.bg_color,
                                msg.write_string.font);
            /* ----------------------------------------------------------------
             * 释放字符串内存
             * 字符串在ui_write_string()中通过pvPortMalloc()分配
             * 绘制完成后必须释放，避免内存泄漏
             * ---------------------------------------------------------------- */
            vPortFree((void*)msg.write_string.str);
            break;
            
        /* ====================================================================
         * 绘制图像操作
         * ==================================================================== */
        case UI_ACTION_DRAW_IMAGE:
            st7789_draw_image(msg.draw_image.x, msg.draw_image.y,
                              msg.draw_image.image);
            break;
            
        /* ====================================================================
         * 未知操作类型（不应该发生）
         * ==================================================================== */
        default:
            printf("Unknown UI action: %d\n", msg.action);
            break;
        }
    }
}

/* ============================================================================
 * 函数：ui_init
 * 功能：初始化UI系统
 * 说明：
 *   1. 创建消息队列
 *   2. 创建UI任务
 *   必须在使用任何UI函数之前调用
 * ============================================================================ */
void ui_init(void)
{
    /* ------------------------------------------------------------------------
     * 创建消息队列
     * 参数1：队列长度 - 最多可以缓存16条UI消息
     * 参数2：消息大小 - 每条消息的字节数
     * ------------------------------------------------------------------------ */
    ui_queue = xQueueCreate(16, sizeof(ui_message_t));
    configASSERT(ui_queue);  // 断言：队列创建必须成功
    
    /* ------------------------------------------------------------------------
     * 创建UI任务
     * 参数1：任务函数
     * 参数2：任务名称（用于调试）
     * 参数3：栈大小 - 1024字（4KB，因为StackType_t是uint32_t）
     * 参数4：任务参数（传递给ui_func）
     * 参数5：任务优先级 - 8（较高优先级，确保UI响应及时）
     * 参数6：任务句柄（不需要，传NULL）
     * ------------------------------------------------------------------------ */
    xTaskCreate(ui_func, "ui", 1024, NULL, 8, NULL);
}

/* ============================================================================
 * 函数：ui_fill_color
 * 功能：填充矩形区域为指定颜色（异步操作）
 * 参数：
 *   x, y   - 矩形左上角坐标
 *   width  - 矩形宽度
 *   height - 矩形高度
 *   color  - 填充颜色（RGB565格式，使用mkcolor宏转换）
 * 说明：
 *   - 函数立即返回，不等待实际绘制完成
 *   - 实际绘制由UI任务异步执行
 * ============================================================================ */
void ui_fill_color(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint16_t color)
{
    ui_message_t msg;                    // 创建消息
    msg.action = UI_ACTION_FILL_COLOR;   // 设置操作类型
    
    /* ------------------------------------------------------------------------
     * 填充填充颜色操作的参数
     * ------------------------------------------------------------------------ */
    msg.fill_color.x = x;
    msg.fill_color.y = y;
    msg.fill_color.width = width;
    msg.fill_color.height = height;
    msg.fill_color.color = color;
    
    /* ------------------------------------------------------------------------
     * 将消息发送到队列
     * portMAX_DELAY: 如果队列已满，永久阻塞直到有空间
     * ------------------------------------------------------------------------ */
    xQueueSend(ui_queue, &msg, portMAX_DELAY);
}
 
/* ============================================================================
 * 函数：ui_write_string
 * 功能：在指定位置绘制字符串（异步操作）
 * 参数：
 *   x, y     - 字符串起始坐标
 *   str      - 字符串内容（会被复制）
 *   color    - 文字颜色
 *   bg_color - 背景颜色
 *   font     - 字体指针
 * 说明：
 *   - 函数会复制字符串到堆内存，因此调用者可以立即释放或修改原字符串
 *   - 复制的字符串会在UI任务绘制完成后自动释放
 * ============================================================================ */
void ui_write_string(uint16_t x, uint16_t y, const char *str, uint16_t color, uint16_t bg_color, const font_t *font)
{
    /* ------------------------------------------------------------------------
     * 分配堆内存并复制字符串
     * 原因：
     *   1. 调用者的字符串可能在栈上（函数返回后失效）
     *   2. 调用者可能在字符串发送到队列后立即修改它
     * 因此必须复制一份，确保UI任务绘制时字符串内容正确
     * ------------------------------------------------------------------------ */
    char *pstr = pvPortMalloc(strlen(str) + 1);  // +1 为字符串结束符'\0'预留空间
    if (pstr == NULL)
    {
        printf("ui write string malloc failed: %s", str);
        return;  // 内存分配失败，放弃本次绘制
    }
    strcpy(pstr, str);  // 复制字符串内容
    
    /* ------------------------------------------------------------------------
     * 创建并填充消息
     * ------------------------------------------------------------------------ */
    ui_message_t msg;
    msg.action = UI_ACTION_WRITE_STRING;  // 设置操作类型
    msg.write_string.x = x;
    msg.write_string.y = y;
    msg.write_string.str = pstr;          // 使用复制的字符串指针
    msg.write_string.color = color;
    msg.write_string.bg_color = bg_color;
    msg.write_string.font = font;
    
    /* ------------------------------------------------------------------------
     * 将消息发送到队列
     * UI任务会在绘制完成后释放pstr指向的内存
     * ------------------------------------------------------------------------ */
    xQueueSend(ui_queue, &msg, portMAX_DELAY);
}

/* ============================================================================
 * 函数：ui_draw_image
 * 功能：在指定位置绘制图像（异步操作）
 * 参数：
 *   x, y  - 图像左上角坐标
 *   image - 图像数据指针（必须指向常量数据，如Flash中的图像）
 * 说明：
 *   - 图像数据不会被复制，因此image指针必须始终有效
 *   - 通常图像数据存储在Flash中的const数组，不会失效
 * ============================================================================ */
void ui_draw_image(uint16_t x, uint16_t y, const image_t *image)
{
    /* ------------------------------------------------------------------------
     * 创建并填充消息
     * 注意：这里不复制图像数据，只传递指针
     * ------------------------------------------------------------------------ */
    ui_message_t msg;
    msg.action = UI_ACTION_DRAW_IMAGE;  // 设置操作类型
    msg.draw_image.x = x;
    msg.draw_image.y = y;
    msg.draw_image.image = image;       // 直接使用原始指针
    
    /* ------------------------------------------------------------------------
     * 将消息发送到队列
     * ------------------------------------------------------------------------ */
    xQueueSend(ui_queue, &msg, portMAX_DELAY);
}

